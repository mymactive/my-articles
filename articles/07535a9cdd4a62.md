---
title: "有限状態機械で整理するフロントエンド設計"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [react, typescript]
published: false
---

<!-- - 序論
  - Finite automatonとは何か
  - Finite automatonの効能とは？
- 例題
  - Finite automatonを丁寧に書く
  - コードに落とし込む
  - Hands On
    1. 設計
       1. Finite Automaton
       2. 状態遷移表
    2. テストと実装
       1. 最も簡単なテスト
       2. 最小の実装
       3. 三角測量
       4. 一般化
    3. リファクタリング
       1. useReducerを使う
- 結び
  - Finite automatonで見通しの良い設計を与えられる
  - TDDは実装を勧める道具 -->

## お題の説明

<!-- 画像を貼る -->
<!-- 仕様を書く -->

バッジをコーディングします
バッジは次の2つの仕様を持ちます

1. バッジは着脱できる
2. バッジは名前を持つ

## 設計をしよう

<!-- Finite Automatonを記述する -->
<!-- 状態遷移表を記述する -->
<!-- 状態遷移表がそのままテストになることを指摘する -->
<!-- Clean Craftsmanshipを引用  -->
まずは実装の前に、分かる範囲で何を作るのかを理解する必要があります
今回は有限オートマトンを使って、「バッジとは何か」を整理します
ところで有限オートマトンとはwikipediaで調べると、次の通りです

> 有限オートマトン（ゆうげんオートマトン、英: finite automaton)または有限状態機械（ゆうげんじょうたいきかい、英: finite state machine, FSM）とは、有限個の状態と遷移と動作の組み合わせからなる数学的に抽象化された「ふるまいのモデル」である。
>
> wikipedia 有限オートマトン[^Finite_Automaton_wikipedia]より引用

これが有限オートマトンの定義ですが、百聞は一見に如かずです
実際に、バッジの有限オートマトンを描いてみましょう

```mermaid
flowchart LR
d((外れている)) -- 外す --> d((外れている))
d((外れている)) -- 付ける --> a((付いている))
a((付いている)) -- 外す --> d((外れている))
```

テキストのみで、バッジとは何かを並べ立てるよりは明快な表現のように与えられたように感じられないでしょうか
実際バッジとは何かを説明しようとすると、「バッジとは”外れている状態”と”付いている状態”があり、イベントとして”外す”と”付ける”がある。”外す”イベントは...」のように長々となるでしょう
適切なモデリングを選ぶことは、対象を理解することに大いに役に立つのです
さらに有限オートマトンの良いところは、自然に状態遷移表が作れることです
状態遷移表とは、次のような「状態遷移」をテーブルとして表したものです

| 現在の状態 | イベント | 次の状態   |
| ---------- | -------- | ---------- |
| 外れている | 付ける   | 付いている |
| 外れている | 外す     | 外れている |
| 付いている | 外す     | 外れている |

なぜ状態遷移表を得ることが大事なのでしょうか
それは、状態遷移表が自然と欲しいテストケースを与えるからです
実際、バッジをテストする場合は、「外す」テストと「付ける」テストが真っ先に思いつくでしょう
では逆はどうでしょうか
つまり、テストケースは状態遷移表の一部を与えるのかという疑問です
この点について書籍Clean Craftsmanshipにて、以下のように述べられています

> すべてのテストはシステムの振る舞いを記述する有限状態機械の遷移である。
>
> Clean Craftsmanship 規律、基準、倫理　第3章「テスト駆動開発応用」[^CC]より引用

すなわち著者の言葉を信じるならば、逆もまた正しいということです
これは有限オートマトンは、簡潔ながら強力な設計の道具であると言えるでしょう
テスト駆動開発の設計の定石と言えばTODOリストですが、設計の手札の1つとして有限オートマトンを加えてみてはいかがでしょうか（もちろん両方を織り交ぜるのは大変素晴らしいアイデアです）

## 型で状況を表現しよう

バッジは`付いている`状態と、`外れている`状態の2種類あります
更にバッジは`付いている`時だけは`名前`を持ちます
これに基づき、型を与えると以下の通りに

```typescript
type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};
```

ではバッジの型は何かというと、これは次のユニオン型です

```typescript
type Badge = DetachedBadge | AttachedBadge;
```

次に`useBadge`の型を考えましょう
`useBadge`は`バッジ`、`付ける`、`外す`の3要素を返せばいいでしょう
ですので以下の通りです

```typescript
type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};
```

このステップで定義した型を1つにすると、次の通りです

```typescript
type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};
```

## 実装

型の準備ができたので早速`useBadge`の実装に入りましょう
<!-- テスト駆動開発から引用 -->

### 自明な一歩

まず最も簡単なテストを作成します
ところで最も簡単なテストとは、何でしょうか
そもそも今回のテストケースは何でしょうか？
<!-- Clean Craftsmanshipの一文を引用する -->

状態遷移表を再度見直しましょう

| 遷移前                 | 状態変化           | 遷移後                 |
| ---------------------- | ------------------ | ---------------------- |
| バッジが外れている     | "金"バッジを付ける | "金"バッジが付いている |
| バッジが外れている     | 外す               | バッジが外れている     |
| "金"バッジが付いている | 外す               | 外れている             |

これらが、そのままテストケースとなります
この中で最も簡単そうなのは、`バッジが外れている時に、バッジを外す`ことでしょう
早速書いてみましょう
（今回テストフレームワークとして、vitestを利用します）

```typescript
import { test } from "vitest";

test("バッジが外れた状態から、外すとバッジは外れている", () => {});
```

この時点で、テストを走らせましょう
以下のようにテストに成功するはずです
<!-- テスト結果の画像を載せる -->

さて何もテストコードを書いていないのに、なぜテストを実行したのでしょうか
それはテストフレームワークが正しく起動することを確かめるためです

問題なくテストに成功したら、テストコードの続きを書きましょう
まずは`useBadge`を呼び出します

```typescript:useBadge.spec.ts
import { expect } from "vitest";
import { renderHook } from "@testing-library/react";
import { useBadge } from "./useBadge";

test("バッジが外れた状態から、外すとバッジは外れている", () => {
  renderHook(() => useBadge());
}
```

この時点でテストコードを走らせると、失敗します
私の環境では下記のエラーが出力されました
<!-- 画像を挿入 -->

`useBadge`がそもそも定義されていませんでしたね
最小のコードでコンパイルエラーを解消しましょう

```typescript:useBadge.ts
type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};

export const useBadge: UseBadge = () => {};
```

実装を追加した後に、テストを実行すると成功します！
しかしこれはとてもひどいコードですね
型エラーもけたたましく鳴り響いています
しかしこれは想定通りであり、テストコードは完成していませんでした
ここで実装を進めることを今回はグッと堪えテストコードに着手しましょう
次は`detach`を実際に呼び出してみましょう

```typescript:useBadge.spec.ts
import { expect } from "vitest";
import { renderHook } from "@testing-library/react";
import { useBadge } from "./useBadge";

test("バッジが外れた状態から、外すとバッジは外れている", () => {
  const { result } = renderHook(() => useBadge());

  result.current.detach();
}
```

この状態でテストを実行すると失敗します
もちろん`detach`というメソッドが`export`されていないからですね
早速実装しましょう

```typescript:useBadge.ts
type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};

export const useBadge: UseBadge = () => {
  const detach = () => {};

  return { detach }
};
```

これでテストがパスします
`detach`もテストを通すためだけのひどいコードですが、実装は後回しにしてテストを完成させましょう

```typescript:useBadge.spec.ts
import { expect } from "vitest";
import { renderHook } from "@testing-library/react";
import { useBadge } from "./useBadge";

test("バッジが外れた状態から、外すとバッジは外れている", () => {
  const { result } = renderHook(() => useBadge());

  result.current.detach();

  expect(result.current.badge).toStrictEqual({
    mode: "detached",
  });
}
```

無事1つのテストケースが完成しました
完成しましたが、これも当然テストに失敗します
`badge`を実装しましょう

```typescript:useBadge.ts
type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};

export const useBadge: UseBadge = () => {
  const badge = { mode: 'detached' }
  const detach = () => {};

  return { badge ,detach }
};
```

これでテストがパスします
パスしますが、ひどいコードですね
少なくとも`badge`はstateであるべきです
ですがここはあえて実装を進めないでもう一個テストケースを追加しようと思います
というのも`UseBadge`の型エラーを先に解消したいと考えたからです

<!-- テスト駆動開発の十分小さなステップ、ちょうどいいステップを引用し、Tipsにまとめる -->

### attachの実装

<!-- 状態遷移表からテストを作ろう -->
| 遷移前                 | 状態変化           | 遷移後                 |
| ---------------------- | ------------------ | ---------------------- |
| バッジが外れている     | "金"バッジを付ける | "金"バッジが付いている |
| バッジが外れている     | 外す               | バッジが外れている     |
| "金"バッジが付いている | 外す               | 外れている             |

早速`attach`を実装しましょう

```typescript:useBadge.spec.ts
import { expect } from "vitest";
import { renderHook } from "@testing-library/react";
import { useBadge } from "./useBadge";

test("バッジが外れた状態から、外すとバッジは外れている", () => {
  const { result } = renderHook(() => useBadge());

  result.current.detach();

  expect(result.current.badge).toStrictEqual({
    mode: "detached",
  });
}

test("バッジが外れた状態から、バッジをつけると、バッジは付いている", () =>{
  const { result } = renderHook(() => useBadge());

  result.current.attach("金");
})
```

`attach`が無いとコンパイルエラーが発生していますので、早速実装します

```typescript:useBadge.ts
type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};

export const useBadge: UseBadge = () => {
  const badge = { mode: 'detached' }
  const detach = () => {};
  const attach = (name: string) => {};

  return { badge ,attach ,detach }
};
```

これでテストがパスしました
ではテストを完成させましょう

```typescript:useBadge.spec.ts
import { expect } from "vitest";
import { renderHook } from "@testing-library/react";
import { useBadge } from "./useBadge";

test("バッジが外れた状態から、外すとバッジは外れている", () => {
  const { result } = renderHook(() => useBadge());

  result.current.detach();

  expect(result.current.badge).toStrictEqual({
    mode: "detached",
  });
}

test("バッジが外れた状態から、バッジをつけると、バッジは付いている", () =>{
  const { result } = renderHook(() => useBadge());

  result.current.attach("金");

  expect(result.current.badge).toStrictEqual({
    mode: "attached",
    name: "金"
  })
})
```

この状況では、想定通り`badge`の値が一致しないとテストに失敗した原因がわかります
<!-- 画像を撮る -->
`useState`を使って、うまく切り替えられるようにしましょう

```typescript:useBadge.ts
import { useState } from 'react';

type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};

export const useBadge: UseBadge = () => {
  const [badge, setBadge] = useState<Badge>({ mode: 'detached' })
  const detach = () => {};
  const attach = (name: string) => {
    setBadge({ mode: 'attached', name, })
  };

  return { badge ,attach ,detach }
};
```

さてさて、これで完璧と思いきや、なぜかテストが失敗します
**テストコードもバグが混入する可能性がある**
これは残念ながら、事実です
しかし、これが理由でテストコードが価値を失うとは限りません
というのもバグの混入確率を下げているのもまた事実だからです
**ソフトウェアにバグが存在しないことを証明することは不可能である**というのは真理です
私たちに残された手段は、ただありとあらゆる方法を用いてソフトウェアが価値を産む確率を高めることに尽きます
自動テストは、その確率を向上させる有効な手法の1つであるということが、これまでの研究、開発、といった営みを通じて人類が得たものでしょう
<!-- Tips: あえてテストが失敗する値をコードに書きこみ、予想通りの失敗させる話を書く。詳細は文献[X]と案内する -->

さて本題に戻りましょう
問題は、コードは正しそうなのに何故かテストコードが動作しないことでした
結論から言えば、これは`状態(state)`の更新前に値を検証してしまったからです
Reactの`状態(state)`はsnapshotのようなものでした
<!-- React beta state snapshot renderingを引用する -->
この`状態(state)`の問題を解決するAPIが`testing-library`の`act`です
これを用いて、テストを改善しましょう
<!-- actの仕組みについてのリンクを貼る. -->

```typescript:useBadge.spec.ts
import { expect } from "vitest";
import { renderHook, act } from "@testing-library/react";
import { useBadge } from "./useBadge";

test("バッジが外れた状態から、外すとバッジは外れている", () => {
  const { result } = renderHook(() => useBadge());

  act(() => {
    result.current.detach();
  })

  expect(result.current.badge).toStrictEqual({
    mode: "detached",
  });
}

test("バッジが外れた状態から、バッジをつけると、バッジは付いている", () =>{
  const { result } = renderHook(() => useBadge());

  act(() => {
    result.current.attach("金");
  });

  expect(result.current.badge).toStrictEqual({
    mode: "attached",
    name: "金"
  });
})
```

再度テストを走らせてみると、パスします
無事`attach`の実装ができました
この段階でコードを見直してみましょう
ところで`detach`が明らかにバグが発生しそうなひどいコードです
状態遷移表に残っていたテストケースを追加して、正しく動作するコードにしましょう

<!-- 実装 -->

### detach再訪

まずは状態遷移表を振り返りましょう

| 遷移前                 | 状態変化           | 遷移後                 |
| ---------------------- | ------------------ | ---------------------- |
| バッジが外れている     | "金"バッジを付ける | "金"バッジが付いている |
| バッジが外れている     | 外す               | バッジが外れている     |
| "金"バッジが付いている | 外す               | 外れている             |

実装に入る前に、最後の行をテストケースとして書き起こしてみましょう

```typescript:useBadge.spec.ts
import { expect } from "vitest";
import { renderHook, act } from "@testing-library/react";
import { useBadge } from "./useBadge";

test("バッジが外れた状態から、外すとバッジは外れている", () => {
  const { result } = renderHook(() => useBadge());

  act(() => {
    result.current.detach();
  })

  expect(result.current.badge).toStrictEqual({
    mode: "detached",
  });
}

test("バッジが外れた状態から、バッジをつけると、バッジは付いている", () =>{
  const { result } = renderHook(() => useBadge());

  act(() => {
    result.current.attach("金");
  });

  expect(result.current.badge).toStrictEqual({
    mode: "attached",
    name: "金"
  });
})

test("バッジが付いている状態から、バッジを外すと、バッジは外れている", () =>{
  // Arrange
  const { result } = renderHook(() => useBadge());

  act(() => {
    result.current.attach("金");
  });

  // Act
  act(() => {
    result.current.detach();
  });

  // Assert
  expect(result.current.badge).toStrictEqual({ mode: "detached" });
})
```

:::message
コードコメント内で、いわゆるAAAパターンを実施しました
AAAとは、Arrange（準備）、Act（実行）、Assert（検証）の頭文字を取ったテストコードの設計パターンです
詳細は`XXXX`を参照してください
:::
<!-- Tips AAAパターンを説明する。単体テストの使い方/考え方を紹介する -->
想定通りテストは失敗します
テストが通るように、`detach`を修正しましょう

```typescript:useBadge.ts
import { useState } from 'react';

type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};

export const useBadge: UseBadge = () => {
  const [badge, setBadge] = useState<Badge>({ mode: 'detached' })
  const detach = () => { setBadge({ mode: "detached" }) };
  const attach = (name: string) => {
    setBadge({ mode: 'attached', name, })
  };

  return { badge, attach, detach }
};
```

テストを走らせると、パスしました！
これで状態遷移表にある全てのケースをテストコードとして実現でき、コードの実装もできました
これで万々歳です
しかしテスト駆動開発の黄金のサイクルのうち、重要なステップであるリファクタリングに言及していませんでした
改めてリファクタリングを一言で述べると、**コードの振る舞いを変えずに、コードを改善すること**です
しかし、この定義は**コードの振る舞い**という言葉が些か曖昧です
良い自動テストが用意されている時は、リファクタリングの定義を次のように言い換えられます
**自動テストを成功させたまま、コードを改善すること**
<!-- この言葉をテスト駆動開発から引用する -->
この定義に言い換えられるのは、良い自動テストがコードの振る舞いを捕捉するからです
この定義は大変強力です
というのも、**コードの振る舞い**という曖昧なものではなく、テストコードというプレーンテキストと、テストの成功または失敗という単純な2値に置き換えられるからです
これは曖昧な言葉よりもずっと解析可能な対象です
実際プレーンテキストなら種々のプログラミング原理、原則が適応可能であり、単純な2値なら判断は明確です
**コードの振る舞い**を可視化するというのも自動テストの功の1つでしょう
次のステップでは実際にリファクタリングをしてみましょう
<!-- バグを起こす -->

## リファクタリング

まずは現在のコードを見返しましょう

```typescript:useBadge.ts
import { useState } from 'react';

type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};

export const useBadge: UseBadge = () => {
  const [badge, setBadge] = useState<Badge>({ mode: 'detached' })
  const detach = () => { setBadge({ mode: "detached" }) };
  const attach = (name: string) => {
    setBadge({ mode: 'attached', name, })
  };

  return { badge,　attach,　detach }
};
```

このコードをより明瞭にできないか考えてみます
このコードを書いているときに私は違和感を感じていました
それは`attach`と`detach`になぜバッジの型情報が表現されていないのかということです
実際に、`attach`と`detach`の型情報を見返すと次の通りです

```typescript
type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};
```

`attach`と`detach`が`void`を返しています
`void`を返していると言うことは、何らかの副作用が生じるコードを表しています
副作用は取り扱いが難しくバグの温床となりやすいということはよく知られていることでしょう
次のように、バッジの情報を返り値に与えれば状態（state）が更新される仕組みだったらコンパイルエラーでもコードが正しく振る舞う確率を上げられるのではないのでしょうか

```typescript
type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => AttachedBadge;
  detach: () => DetachedBadge;
};
```

これはもちろん疑似コードであり、状態（state）の更新はReactの仕事のため動作しません
しかしちょうどいい解決方法がReactから提供されています
それは`useReducer`です
<!-- `useReducer`について簡単に述べる -->
`reducer`周りの実装をする前に、型で実装したい事柄を表現しましょう
まずは`reducer`のアクションを型で表現します
`attach`と`detach`という2種類のアクションを持つので、`reducer`のアクションタイプはこのようになるでしょう

```typescript
type AttachAction = { type: 'attach', name: string};
type DetachAction = { type: 'detach'};
type Action = AttachAction | DetachAction;
```

次は`reducer`の型を用意しましょう
さらに`reducer`内部ではアクションタイプに応じて`attach`と`detach`を呼ぶ設計にします

```typescript
type AttachAction = { type: 'attach', name: string};
type DetachAction = { type: 'detach'};
type Action = AttachAction | DetachAction;

type AttachInReducer = (name: string) => AttachedTag;
type DetachInReducer = () => DetachedTag;
type Reducer = (badge: Badge, type: ActionType) => Badge;
```

この型に基づいて、実装してみましょう

```typescript
type AttachAction = { type: 'attach', name: string};
type DetachAction = { type: 'detach'};
type Action = AttachAction | DetachAction;

type AttachInReducer = (name: string) => AttachedTag;
type DetachInReducer = () => DetachedTag;
type Reducer = (badge: Badge, type: ActionType) => Badge;

const attachInReducer: AttachInReducer = (name) => ({ mode: 'attached', name });
const detachInReducer: DetachedInReducer = () => ({ mode: 'detached' });
const reducer: Reducer = (_, type) => {
  switch (action.type) {
    case "attach":
      return attachInReducer(action.name);
    case "detach":
      return detachInReducer();
    default:
      throw new Error("invalid action");
}
```

このreducerを使って、リファクタリングをやってみましょう

```typescript:useBadge.ts
import { useReducer } from "react";

type DetachedBadge = {
  mode: "detached";
};

type AttachedBadge = {
  mode: "attached";
  name: string;
};

type Badge = DetachedBadge | AttachedBadge;

type UseBadge = () => {
  badge: Badge;
  attach: (name: string) => void;
  detach: () => void;
};

type AttachAction = { type: "attach"; name: string };
type DetachAction = { type: "detach" };
type Action = AttachAction | DetachAction;
type AttachInReducer = (name: string) => AttachedBadge;
type DetachInReducer = () => DetachedBadge;
type Reducer = (badge: Badge, action: Action) => Badge;

const attachInReducer: AttachInReducer = (name) => ({ mode: "attached", name });
const detachInReducer: DetachInReducer = () => ({ mode: "detached" });
const reducer: Reducer = (_, action) => {
  switch (action.type) {
    case "attach":
      return attachInReducer(action.name);
    case "detach":
      return detachInReducer();
    default:
      throw new Error("invalid action");
  }
};

export const useBadge: UseBadge = () => {
  const [badge, dispatch] = useReducer(reducer, { mode: "detached" });

  const attach = (name: string) => dispatch({ type: "attach", name });

  const detach = () => dispatch({ type: "detach" });

  return { badge, attach, detach };
};
```

最後に、テストを走らせましょう
パスしました！これでリファクタリングが完了です！

最後にリファクタリングのきっかけを振り返りましょう
リファクタリングの糸口は、バッジの操作である`attach`と`detach`にバッジの情報が型の世界では欠落していることへの違和感でした
ではなぜ違和感を感じられたのかを掘り下げると、参考文献[^DMMF][^DMMF_2022][^バックエンド再考]にてドメインを型で表現する考え方を学べていたからです
ではなぜこれら参考文献に出会えたのかというと、それは単なる偶然です
結局のところコード設計のひらめきは偶然の産物です
ですが、このことに落胆する必要はありません
書籍「テスト駆動開発」[^TDD]の言葉を紹介します

> TDDは、設計のひらめきが正しい瞬間に訪れることを保証するものではない。しかし、自信を与えてくれるテストときちんと手入れされたコードは、ひらめきへの備えであり、いざひらめいたときに、それを具現化するための備えでもある
>
> テスト駆動開発[^TDD] 第12章「式とメタファー」より引用

この書籍を読んだ多くの方が、この言葉が好きだと勝手に思っています
もちろん私もこの言葉が好きです
ひらめきをコードに反映できたのは、きちんと備えていたからでしょう
つまり学んだことを実際に使える喜びをテスト駆動開発は与えてくれるというのは大袈裟な表現かもしれません
ですが、その喜びに出会う確率を向上させることには役に立つでしょう

<!-- 状態を確認するテストであることを指摘する -->
<!-- 状態を確認するテストは単体テストの使い方・考え方より引用 -->

## 結び

<!-- 実際のコードはここまで型の設計がうまくいかないことは多い→テスト駆動開発とうでより書籍を読もう -->
<!-- テストはソフトウェアの質を向上させない、質を把握するだけ→コード設計の本を読む -->
<!-- テストそのものの考え方・使い方は良いだろうか？→単体テストの使い方・考え方で単体テストもプロダクションコードの意識を学ぼう -->
<!-- テストケースは十分だったか？テスト設計の本を紹介する -->
<!-- 自動テストは世界を広げる→フィードバックが得られる特性→色々な技術への興味が持てるかも？ -->

## 参考文献

[^DMMF]: [Scott Wlaschin. Domain Modeling Made Functional. Pragmatic Bookshelf, 2018.](https://pragprog.com/titles/swdddf/domain-modeling-made-functional/)
[^TDD]: [Kent Beck 著 和田卓人訳. テスト駆動開発. オーム社, 2017.](https://shop.ohmsha.co.jp/shopdetail/000000004967/)
[^UTP3]: [Vladimir Khorikov 著 須田智之編. 単体テストの考え方/使い方. マイナビ出版, 2022.](https://book.mynavi.jp/ec/products/detail/id=134252)
[^CC]: [Robert C. Martin 著 角 征典訳. Clean Craftsmanship 規律、基準、倫理. KADOKAWA, 2022.](https://www.kadokawa.co.jp/product/302206001224/)
[^DMMF_2022]: [Scott Wlaschin. Domain Modeling Made Functional, DevTernity 2022.](https://www.slideshare.net/ScottWlaschin/domain-modeling-made-functional-devternity-2022)
[^バックエンド再考]: [伊藤 直也. フロントエンドのパラダイムを参考にバックエンド開発を再考する/ TypeScript による GraphQL バックエンド開発, 2022.](https://speakerdeck.com/naoya/typescript-niyoru-graphql-batukuendokai-fa)
[^Finite_Automaton_wikipedia]: [有限オートマトン, wikipedia](https://ja.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3#:~:text=%E6%9C%89%E9%99%90%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3%EF%BC%88%E3%82%86%E3%81%86%E3%81%92%E3%82%93%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3%E3%80%81%E8%8B%B1,%E3%81%B5%E3%82%8B%E3%81%BE%E3%81%84%E3%81%AE%E3%83%A2%E3%83%87%E3%83%AB%E3%80%8D%E3%81%A7%E3%81%82%E3%82%8B%E3%80%82)
